// Gold Standard Registry Bridge — Webhook-based Credit Mirroring
// Handles: webhook ingest, batch credit registration, bridge locking, status sync
// registry_type: 1 = gold_standard (see source_network.fl)
//
// State Machine (SC-SPEC-005 §4.5):
//   PENDING(0) → SUBMITTED(1) → MIRRORED(2) → SYNCED(3)
//   Any active state → REJECTED(4)
//   REJECTED(4) → PENDING(0) on retry
//
// BRIDGE_LOCKED: true in {PENDING, SUBMITTED, MIRRORED}
//   Prevents double-count across registries during bridge submission.

type GoldStandardConfig = struct {
    bridge_id: bytes(16),
    api_endpoint_hash: bytes(32),
    credential_vault_ref: bytes(32),
    webhook_secret_hash: bytes(32),
    batch_max_size: u32,
    webhook_timeout_ms: u32,
    retry_max: u8,
    min_vintage_year: u16,
    max_sdg_goals: u8,
}

type WebhookPayload = struct {
    event_id: bytes(16),
    event_type: u8,
    timestamp: u64,
    gs_project_id: bytes(16),
    gs_serial: string,
    credit_quantity: f64,
    vintage_year: u16,
    methodology_id: string,
    signature: bytes(64),
}

type CreditMirrorRequest = struct {
    credit_id: bytes(16),
    gs_serial: string,
    attestation_hash: bytes(32),
    credit_metadata_hash: bytes(32),
    tonnes_co2e: f64,
    vintage_year: u16,
    project_name: string,
    project_location: string,
    methodology_id: string,
    sdg_goals: list<u8>,
}

type BatchRegistration = struct {
    batch_id: bytes(16),
    credits: list<CreditMirrorRequest>,
    submitted_at: u64,
    batch_size: u32,
}

type MirrorStatus = struct {
    credit_id: bytes(16),
    gs_serial: string,
    state: u8,
    bridge_locked: bool,
    last_updated: u64,
    retry_count: u8,
    error_code: u16,
    sdg_score: f64,
}

type GoldStandardValidation = struct {
    serial_valid: bool,
    vintage_valid: bool,
    quantity_valid: bool,
    sdg_score: f64,
    overall_valid: bool,
    error_code: u16,
}

// conflict_type: 0=state_mismatch, 1=quantity_mismatch, 2=missing_local, 3=missing_remote
type SyncConflict = struct {
    credit_id: bytes(16),
    gs_serial: string,
    local_state: u8,
    remote_state: u8,
    conflict_type: u8,
    detected_at: u64,
    resolved: bool,
}

// operation: 0=mirror, 1=retire, 2=transfer, 3=sync, 4=lock, 5=unlock
type BridgeTransaction = struct {
    tx_id: bytes(32),
    credit_id: bytes(16),
    gs_serial: string,
    operation: u8,
    vrf_proof: bytes(64),
    timestamp: u64,
}

type BatchResult = struct {
    batch_id: bytes(16),
    total: f64,
    accepted: f64,
    rejected: f64,
    total_tonnes: f64,
}

// event_type: 0=credit_issued, 1=credit_retired, 2=credit_transferred, 3=status_update
// state: 0=pending, 1=submitted, 2=mirrored, 3=synced, 4=rejected

state_machine gs_credit_lifecycle {
    initial PENDING
    persistence wal
    terminal [SYNCED]
    li_anomaly_detection true

    PENDING -> SUBMITTED when credit_submitted guard serial_valid
    PENDING -> REJECTED when validation_failed
    SUBMITTED -> MIRRORED when registry_accepted
    SUBMITTED -> REJECTED when registry_rejected
    MIRRORED -> SYNCED when sync_confirmed guard bridge_consistent
    MIRRORED -> REJECTED when sync_failed
    REJECTED -> PENDING when retry_requested guard retry_eligible
}

graph gold_standard_bridge_graph {
    node GoldStandardConfig
    node WebhookPayload
    node CreditMirrorRequest
    node BatchRegistration
    node MirrorStatus
    node GoldStandardValidation
    node SyncConflict
    node BridgeTransaction
    edge mirrors: CreditMirrorRequest -> MirrorStatus { guard credit_valid }
    edge batches: BatchRegistration -> CreditMirrorRequest { guard batch_open }
    edge webhook_triggers: WebhookPayload -> MirrorStatus { guard signature_valid }
    edge validates: CreditMirrorRequest -> GoldStandardValidation { guard serial_format }
    edge transactions: BridgeTransaction -> MirrorStatus { guard vrf_valid }
    edge conflicts: SyncConflict -> MirrorStatus { guard conflict_detected }
    overlay mirror_state: u8 curate delta_curate
    overlay bridge_lock: u8 curate delta_curate
    overlay batch_progress: u64 bitmask delta_curate
    overlay sdg_scores: f64 curate delta_curate
    storage csr {
        hot @bram,
        warm @ddr,
        cold @nvme,
    }
    ai_feed mirror_anomaly
    ai_feed batch_throughput
    ai_feed sdg_alignment
    observe gold_standard_bridge_graph: [mirror_state, bridge_lock, batch_progress, sdg_scores] threshold: {
        anomaly_score 0.85
        baseline_window 120
    }
}

series gs_mirror_events: gold_standard_bridge_graph
    merkle_chain true
    lattice_imprint true
    witness_attest true

// ---------------------------------------------------------------------------
// Verify and ingest a Gold Standard webhook payload.
// Migrated from: webhook.ts GoldStandardWebhookReceiver.verifySignature + handleEvent
// ---------------------------------------------------------------------------
circuit gs_webhook_ingest(graph_id: bytes(32), payload: WebhookPayload, raw_body: bytes(4096)) -> bytes(16)
    subscribe sc.bridges.gold_standard.webhook
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/webhook
    precision C
    povc true
    observe metrics: [event_id, event_type, gs_serial, credit_quantity]
    invariant "timestamp_window" { abs(now_ms - payload_ts) <= timeout_ms }
{
    let config = eslite_query("gs_bridge_config", graph_id)
    let now_ms = now() * 1.0
    let payload_ts = payload.timestamp * 1.0
    let delta_ms = abs(now_ms - payload_ts)
    let timeout_ms = config.webhook_timeout_ms * 1.0

    // Replay protection: 5-minute window (webhook.ts verifySignature)
    let timestamp_ok = delta_ms <= timeout_ms

    // Signature verification — HMAC-SHA256 over "timestamp.body"
    let sig_payload = sha3_256(payload.timestamp ++ raw_body)
    let sig_ok = vrf_verify(payload.signature, sig_payload, config.webhook_secret_hash)

    let existing = eslite_query("gs_mirror_by_serial", payload.gs_serial)
    let current_state = existing.state * 1.0

    // Map event_type to target bridge state (webhook.ts handleEvent dispatch)
    // 0=credit_issued → MIRRORED(2)
    // 1=credit_retired → SYNCED(3)
    // 2=credit_transferred → hold current state
    // 3=status_update → classify from remote status
    let issued_target = 2.0
    let retired_target = 3.0
    let classify_target = ai_classify("gs_status_to_bridge_state", payload.methodology_id)
    let target_state = if payload.event_type == 0 { issued_target }
        else if payload.event_type == 1 { retired_target }
        else if payload.event_type == 3 { classify_target }
        else { current_state }

    let new_state = fsm_transition("gs_credit_lifecycle", current_state, target_state)

    // BRIDGE_LOCKED: true in {PENDING(0), SUBMITTED(1), MIRRORED(2)}
    let bridge_locked = new_state < 3.0

    let updated = MirrorStatus {
        credit_id: existing.credit_id,
        gs_serial: payload.gs_serial,
        state: round(new_state),
        bridge_locked: bridge_locked,
        last_updated: now(),
        retry_count: existing.retry_count,
        error_code: if timestamp_ok { 0 } else { 4001 },
        sdg_score: existing.sdg_score,
    }
    eslite_insert("gs_mirror_mappings", existing.credit_id, updated)

    // VRF audit trail
    let vrf_seed = payload.event_id ++ payload.gs_serial ++ now()
    let tx_proof = vrf_prove(vrf_seed)
    let tx_id = sha3_256(tx_proof)
    eslite_insert("gs_bridge_transactions", tx_id, BridgeTransaction {
        tx_id: tx_id,
        credit_id: existing.credit_id,
        gs_serial: payload.gs_serial,
        operation: payload.event_type,
        vrf_proof: tx_proof,
        timestamp: now(),
    })

    stream_sight_anomaly("gs_webhook_rate", delta_ms)

    payload.event_id
}

// ---------------------------------------------------------------------------
// Mirror a single credit from SC to Gold Standard.
// Migrated from: mapping.ts MirrorMappingStore.create + client.ts registerCredit
// ---------------------------------------------------------------------------
circuit gs_mirror_credit(graph_id: bytes(32), request: CreditMirrorRequest) -> MirrorStatus
    subscribe sc.credits.issued
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/mirror
    precision C
    povc true
    observe metrics: [credit_id, gs_serial, tonnes_co2e, methodology_id]
    invariant "tonnes_positive" { request.tonnes_co2e > 0.0 }
    invariant "serial_gs_prefix" { serial_valid == true }
{
    // GS serial format validation (must carry GS prefix)
    let serial_valid = ai_classify("gs_serial_format", request.gs_serial)

    // Vintage year range: Gold Standard founded 2003, cap at reasonable future
    let config = eslite_query("gs_bridge_config", graph_id)
    let vintage_f = request.vintage_year * 1.0
    let min_vintage = config.min_vintage_year * 1.0
    let vintage_valid = vintage_f >= min_vintage

    // Quantity must be positive
    let quantity_valid = request.tonnes_co2e > 0.0

    // SDG co-benefit scoring via AI classifier on methodology + project
    let sdg_input = request.methodology_id ++ request.project_name ++ request.project_location
    let sdg_raw = ai_infer("gs_sdg_alignment", sdg_input)
    let sdg_score = 1.0 / (1.0 + exp(0.0 - sdg_raw))

    // Duplicate check — reject if mapping already exists
    let dup_check = eslite_query("gs_mirror_mappings", request.credit_id)
    let is_duplicate = dup_check.state >= 0.0

    // Deterministic bridge transaction ID via VRF
    let vrf_seed = request.credit_id ++ request.gs_serial ++ request.attestation_hash
    let tx_proof = vrf_prove(vrf_seed)
    let tx_id = sha3_256(tx_proof)

    // Acquire cross-bridge lock (bridge_lock.fl) — prevents dual-listing on Verra/CDM
    eslite_insert("gs_bridge_lock", request.credit_id, 1)

    // Initial state: PENDING(0), bridge locked (mapping.ts create)
    let initial_state = 0
    let status = MirrorStatus {
        credit_id: request.credit_id,
        gs_serial: request.gs_serial,
        state: initial_state,
        bridge_locked: true,
        last_updated: now(),
        retry_count: 0,
        error_code: 0,
        sdg_score: sdg_score,
    }

    eslite_insert("gs_mirror_mappings", request.credit_id, status)
    eslite_insert("gs_mirror_by_serial", request.gs_serial, status)

    // Persist validation record
    eslite_insert("gs_validations", request.credit_id, GoldStandardValidation {
        serial_valid: serial_valid,
        vintage_valid: vintage_valid,
        quantity_valid: quantity_valid,
        sdg_score: sdg_score,
        overall_valid: serial_valid && vintage_valid && quantity_valid,
        error_code: 0,
    })

    // Audit trail
    eslite_insert("gs_bridge_transactions", tx_id, BridgeTransaction {
        tx_id: tx_id,
        credit_id: request.credit_id,
        gs_serial: request.gs_serial,
        operation: 0,
        vrf_proof: tx_proof,
        timestamp: now(),
    })

    stream_sight_anomaly("gs_mirror_volume", request.tonnes_co2e)

    status
}

// ---------------------------------------------------------------------------
// Register a batch of credits with Gold Standard.
// Migrated from: client.ts registerBatch
// ---------------------------------------------------------------------------
circuit gs_batch_register(graph_id: bytes(32), batch: BatchRegistration) -> bytes(16)
    subscribe sc.credits.issued
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/batch
    precision C
    povc true
    observe metrics: [batch_id, batch_size, submitted_at]
    invariant "batch_size_limit" { batch.batch_size <= config_max }
{
    let config = eslite_query("gs_bridge_config", graph_id)
    let config_max = config.batch_max_size * 1.0
    let batch_count = batch.batch_size * 1.0

    // Validate batch doesn't exceed configured maximum
    let size_ok = batch_count <= config_max

    // Aggregate tonnes across all credits in the batch
    let total_tonnes = percentile(batch.credits, 100.0)

    // Deterministic batch ID via VRF
    let vrf_seed = batch.batch_id ++ batch.submitted_at
    let batch_proof = vrf_prove(vrf_seed)
    let batch_vrf_id = sha3_256(batch_proof)

    // Persist batch metadata
    eslite_insert("gs_batch_registry", batch.batch_id, BatchResult {
        batch_id: batch.batch_id,
        total: batch_count,
        accepted: 0.0,
        rejected: 0.0,
        total_tonnes: total_tonnes,
    })

    // Audit trail for the batch operation
    eslite_insert("gs_bridge_transactions", batch_vrf_id, BridgeTransaction {
        tx_id: batch_vrf_id,
        credit_id: batch.batch_id,
        gs_serial: "",
        operation: 0,
        vrf_proof: batch_proof,
        timestamp: now(),
    })

    stream_sight_anomaly("gs_batch_size", batch_count)

    batch.batch_id
}

// ---------------------------------------------------------------------------
// Transition mirror state: PENDING → SUBMITTED → MIRRORED → SYNCED
// Migrated from: mapping.ts MirrorMappingStore.updateState + isValidTransition
// ---------------------------------------------------------------------------
circuit gs_update_mirror_state(graph_id: bytes(32), credit_id: bytes(16), new_state: u8) -> MirrorStatus
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/state
    precision C
    povc true
    observe metrics: [credit_id, new_state]
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)
    let current_state = existing.state * 1.0
    let target_state = new_state * 1.0

    // Validate transition against gs_credit_lifecycle FSM
    // Valid: 0→1, 0→4, 1→2, 1→4, 2→3, 2→4, 4→0
    let validated_state = fsm_transition("gs_credit_lifecycle", current_state, target_state)

    // BRIDGE_LOCKED semantics (mapping.ts isBridgeLocked):
    //   locked:   PENDING(0), SUBMITTED(1), MIRRORED(2)
    //   unlocked: SYNCED(3), REJECTED(4)
    let bridge_locked = validated_state < 3.0

    // Increment retry counter on REJECTED → PENDING retry path
    let retry_inc = if current_state == 4.0 && validated_state == 0.0 { 1 } else { 0 }
    let new_retry = existing.retry_count + retry_inc

    let updated = MirrorStatus {
        credit_id: credit_id,
        gs_serial: existing.gs_serial,
        state: round(validated_state),
        bridge_locked: bridge_locked,
        last_updated: now(),
        retry_count: new_retry,
        error_code: 0,
        sdg_score: existing.sdg_score,
    }

    eslite_insert("gs_mirror_mappings", credit_id, updated)
    eslite_insert("gs_mirror_by_serial", existing.gs_serial, updated)

    stream_sight_anomaly("gs_state_transitions", validated_state)

    updated
}

// ---------------------------------------------------------------------------
// Lock a credit during bridge submission (double-count prevention).
// Migrated from: mapping.ts isBridgeLocked + MirrorMappingStore (LOCKED_STATES)
// ---------------------------------------------------------------------------
circuit gs_bridge_lock(graph_id: bytes(32), credit_id: bytes(16)) -> bool
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/lock
    precision C
    povc true
    observe metrics: [credit_id]
    invariant "not_already_locked" { existing_locked == false }
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)
    let existing_locked = existing.bridge_locked
    let state_f = existing.state * 1.0

    // Only lockable in active states (PENDING, SUBMITTED, MIRRORED)
    let lockable = state_f < 3.0

    let updated = MirrorStatus {
        credit_id: credit_id,
        gs_serial: existing.gs_serial,
        state: existing.state,
        bridge_locked: true,
        last_updated: now(),
        retry_count: existing.retry_count,
        error_code: if lockable { 0 } else { 4010 },
        sdg_score: existing.sdg_score,
    }
    eslite_insert("gs_mirror_mappings", credit_id, updated)

    // Cross-bridge lock record
    eslite_insert("gs_bridge_lock", credit_id, 1)

    let vrf_seed = credit_id ++ now()
    let tx_proof = vrf_prove(vrf_seed)
    eslite_insert("gs_bridge_transactions", sha3_256(tx_proof), BridgeTransaction {
        tx_id: sha3_256(tx_proof),
        credit_id: credit_id,
        gs_serial: existing.gs_serial,
        operation: 4,
        vrf_proof: tx_proof,
        timestamp: now(),
    })

    lockable
}

// ---------------------------------------------------------------------------
// Unlock a credit after rejection from Gold Standard.
// Migrated from: mapping.ts updateState (REJECTED path clears bridge_locked)
// ---------------------------------------------------------------------------
circuit gs_bridge_unlock(graph_id: bytes(32), credit_id: bytes(16), reason: string) -> bool
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/unlock
    precision C
    povc true
    observe metrics: [credit_id, reason]
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)
    let state_f = existing.state * 1.0

    // Only REJECTED(4) credits can be unlocked (mapping.ts: bridge_locked = false on REJECTED)
    let is_rejected = state_f == 4.0

    // Check retry eligibility: retry_count < config.retry_max
    let config = eslite_query("gs_bridge_config", graph_id)
    let retries_remaining = config.retry_max * 1.0 - existing.retry_count * 1.0
    let retry_eligible = retries_remaining > 0.0

    let updated = MirrorStatus {
        credit_id: credit_id,
        gs_serial: existing.gs_serial,
        state: existing.state,
        bridge_locked: false,
        last_updated: now(),
        retry_count: existing.retry_count,
        error_code: if is_rejected { 0 } else { 4020 },
        sdg_score: existing.sdg_score,
    }
    eslite_insert("gs_mirror_mappings", credit_id, updated)

    // Release cross-bridge lock
    eslite_insert("gs_bridge_lock", credit_id, 0)

    let vrf_seed = credit_id ++ reason ++ now()
    let tx_proof = vrf_prove(vrf_seed)
    eslite_insert("gs_bridge_transactions", sha3_256(tx_proof), BridgeTransaction {
        tx_id: sha3_256(tx_proof),
        credit_id: credit_id,
        gs_serial: existing.gs_serial,
        operation: 5,
        vrf_proof: tx_proof,
        timestamp: now(),
    })

    is_rejected
}

// ---------------------------------------------------------------------------
// Sync retirement event between SC and Gold Standard.
// Migrated from: client.ts retireCredit + webhook.ts handleCreditRetired
// ---------------------------------------------------------------------------
circuit gs_sync_retirement(graph_id: bytes(32), credit_id: bytes(16), gs_serial: string, beneficiary: string, reason: string) -> bool
    subscribe sc.credits.retired
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/retirement
    precision C
    povc true
    observe metrics: [credit_id, gs_serial, beneficiary]
    invariant "must_be_locked" { existing_locked == true }
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)
    let existing_locked = existing.bridge_locked
    let state_f = existing.state * 1.0

    // Retirement only valid from MIRRORED(2) or already SYNCED(3)
    let retirement_eligible = state_f == 2.0 || state_f == 3.0

    // FSM transition to SYNCED(3) — terminal state
    let new_state = fsm_transition("gs_credit_lifecycle", state_f, 3.0)

    // Retirement certificate hash
    let cert_hash = sha3_256(credit_id ++ gs_serial ++ beneficiary ++ reason)

    let updated = MirrorStatus {
        credit_id: credit_id,
        gs_serial: gs_serial,
        state: round(new_state),
        bridge_locked: false,
        last_updated: now(),
        retry_count: existing.retry_count,
        error_code: if retirement_eligible { 0 } else { 4030 },
        sdg_score: existing.sdg_score,
    }
    eslite_insert("gs_mirror_mappings", credit_id, updated)
    eslite_insert("gs_mirror_by_serial", gs_serial, updated)

    // Release bridge lock on retirement (terminal state)
    eslite_insert("gs_bridge_lock", credit_id, 0)

    // VRF audit trail for retirement
    let vrf_seed = credit_id ++ gs_serial ++ cert_hash ++ now()
    let tx_proof = vrf_prove(vrf_seed)
    let tx_id = sha3_256(tx_proof)
    eslite_insert("gs_bridge_transactions", tx_id, BridgeTransaction {
        tx_id: tx_id,
        credit_id: credit_id,
        gs_serial: gs_serial,
        operation: 1,
        vrf_proof: tx_proof,
        timestamp: now(),
    })

    stream_sight_anomaly("gs_retirement_rate", 1.0)

    retirement_eligible
}

// ---------------------------------------------------------------------------
// Validate a credit against Gold Standard-specific rules.
// Migrated from: mapping.ts validation logic + GS registry requirements
// ---------------------------------------------------------------------------
circuit gs_validate_credit(graph_id: bytes(32), request: CreditMirrorRequest) -> GoldStandardValidation
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/validate
    precision C
    povc true
    observe metrics: [credit_id, gs_serial, vintage_year, tonnes_co2e]
{
    let config = eslite_query("gs_bridge_config", graph_id)

    // GS serial format: must classify as valid Gold Standard serial (GS-prefixed)
    let serial_valid = ai_classify("gs_serial_format", request.gs_serial)

    // Vintage year: must be >= config minimum (Gold Standard founded 2003)
    let vintage_f = request.vintage_year * 1.0
    let min_vintage_f = config.min_vintage_year * 1.0
    let vintage_valid = vintage_f >= min_vintage_f

    // Quantity: must be positive and within sane bounds
    let quantity_valid = request.tonnes_co2e > 0.0

    // SDG co-benefit alignment score
    // Uses AI model trained on Gold Standard methodology ↔ SDG mappings
    let sdg_input = request.methodology_id ++ request.project_location
    let sdg_raw = ai_infer("gs_sdg_alignment", sdg_input)
    let sdg_score = 1.0 / (1.0 + exp(0.0 - sdg_raw))

    // Overall validity requires all individual checks
    let overall = serial_valid && vintage_valid && quantity_valid

    // Error code encoding: bitfield of failed checks
    let err_serial = if serial_valid { 0.0 } else { 1.0 }
    let err_vintage = if vintage_valid { 0.0 } else { 2.0 }
    let err_quantity = if quantity_valid { 0.0 } else { 4.0 }
    let error_code = round(err_serial + err_vintage + err_quantity)

    GoldStandardValidation {
        serial_valid: serial_valid,
        vintage_valid: vintage_valid,
        quantity_valid: quantity_valid,
        sdg_score: sdg_score,
        overall_valid: overall,
        error_code: error_code,
    }
}

// ---------------------------------------------------------------------------
// Score SDG alignment for a Gold Standard methodology.
// Gold Standard credits must demonstrate co-benefits aligned to at least
// 3 UN Sustainable Development Goals. Returns normalized score [0.0, 1.0].
// ---------------------------------------------------------------------------
circuit gs_sdg_alignment_score(graph_id: bytes(32), methodology_id: string, project_location: string, sdg_goals: list<u8>) -> f64
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/sdg
    precision C
    observe metrics: [methodology_id, sdg_score]
{
    // AI inference on methodology text and project geography
    let context = methodology_id ++ project_location
    let raw_score = ai_infer("gs_sdg_alignment", context)

    // Sigmoid normalization to [0.0, 1.0]
    let normalized = 1.0 / (1.0 + exp(0.0 - raw_score))

    // Goal coverage penalty: Gold Standard requires >= 3 SDG alignments
    let goal_count = percentile(sdg_goals, 100.0)
    let coverage_factor = if goal_count >= 3.0 { 1.0 } else { goal_count / 3.0 }

    // Weighted score combining AI inference with goal coverage
    let final_score = normalized * 0.7 + coverage_factor * 0.3

    stream_sight_anomaly("gs_sdg_scores", final_score)

    final_score
}

// ---------------------------------------------------------------------------
// Detect sync conflicts between local SC state and Gold Standard registry.
// Migrated from: webhook.ts handleStatusUpdated + mapping.ts BridgeStateFromGSStatus
// ---------------------------------------------------------------------------
circuit gs_detect_sync_conflict(graph_id: bytes(32), credit_id: bytes(16), gs_serial: string, remote_state: u8, remote_quantity: f64) -> SyncConflict
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/sync-conflict
    precision C
    povc true
    observe metrics: [credit_id, gs_serial, local_state, remote_state, conflict_type]
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)
    let local_state = existing.state * 1.0
    let remote_f = remote_state * 1.0

    // State mismatch detection
    let state_delta = abs(local_state - remote_f)
    let state_mismatch = state_delta > 0.0

    // Quantity mismatch detection (tolerance: 0.001 tCO2e for floating-point)
    let local_qty = eslite_query("gs_credit_quantity", credit_id)
    let qty_delta = abs(local_qty - remote_quantity)
    let qty_mismatch = qty_delta > 0.001

    // Classify conflict type
    //   0 = state_mismatch, 1 = quantity_mismatch
    //   state_mismatch takes precedence
    let conflict_type = if state_mismatch { 0 }
        else if qty_mismatch { 1 }
        else { 255 }

    let has_conflict = state_mismatch || qty_mismatch

    // Anomaly scoring on the conflict
    let anomaly_input = state_delta + qty_delta * 100.0
    stream_sight_anomaly("gs_sync_conflicts", anomaly_input)

    let conflict = SyncConflict {
        credit_id: credit_id,
        gs_serial: gs_serial,
        local_state: existing.state,
        remote_state: remote_state,
        conflict_type: conflict_type,
        detected_at: now(),
        resolved: false,
    }

    if has_conflict {
        eslite_insert("gs_sync_conflicts", credit_id, conflict)
    }

    conflict
}

// ---------------------------------------------------------------------------
// Map a Gold Standard API status string to bridge state.
// Migrated from: mapping.ts BridgeStateFromGSStatus
// ---------------------------------------------------------------------------
circuit gs_map_remote_status(graph_id: bytes(32), gs_serial: string, remote_status: string) -> u8
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/status-map
    precision B
    observe metrics: [gs_serial, remote_status]
{
    // Gold Standard status → bridge state mapping:
    //   "pending_review" → SUBMITTED(1)
    //   "active"         → MIRRORED(2)
    //   "retired"        → SYNCED(3)
    //   "verified"       → SYNCED(3)
    //   "rejected"       → REJECTED(4)
    //   "cancelled"      → REJECTED(4)
    //   unknown          → PENDING(0)
    let mapped = ai_classify("gs_status_to_bridge_state", remote_status)
    round(mapped)
}

// ---------------------------------------------------------------------------
// Record a bridge error and increment retry counter.
// Migrated from: mapping.ts MirrorMappingStore.recordError
// ---------------------------------------------------------------------------
circuit gs_record_error(graph_id: bytes(32), credit_id: bytes(16), error_code: u16, error_detail: string) -> MirrorStatus
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/error
    precision C
    povc true
    observe metrics: [credit_id, error_code]
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)
    let config = eslite_query("gs_bridge_config", graph_id)

    let new_retry = existing.retry_count + 1
    let max_retries = config.retry_max * 1.0
    let retries_exhausted = new_retry * 1.0 >= max_retries

    // If retries exhausted, transition to REJECTED
    let current_state = existing.state * 1.0
    let forced_state = if retries_exhausted {
        fsm_transition("gs_credit_lifecycle", current_state, 4.0)
    } else { current_state }

    let bridge_locked = forced_state < 3.0

    let updated = MirrorStatus {
        credit_id: credit_id,
        gs_serial: existing.gs_serial,
        state: round(forced_state),
        bridge_locked: bridge_locked,
        last_updated: now(),
        retry_count: new_retry,
        error_code: error_code,
        sdg_score: existing.sdg_score,
    }
    eslite_insert("gs_mirror_mappings", credit_id, updated)

    stream_sight_anomaly("gs_error_rate", error_code * 1.0)

    updated
}

// ---------------------------------------------------------------------------
// Update the GS serial number on an existing mapping.
// Migrated from: mapping.ts MirrorMappingStore.updateGsSerial
// ---------------------------------------------------------------------------
circuit gs_update_serial(graph_id: bytes(32), credit_id: bytes(16), new_gs_serial: string) -> MirrorStatus
    publish sc.bridges.gold_standard.status
    lex esn/sustainability/carbon/org/synergycarbon/registry/bridges/gold-standard/update-serial
    precision C
    povc true
    observe metrics: [credit_id, new_gs_serial]
{
    let existing = eslite_query("gs_mirror_mappings", credit_id)

    // Validate new serial format
    let serial_valid = ai_classify("gs_serial_format", new_gs_serial)

    // Remove old serial index
    eslite_insert("gs_mirror_by_serial", existing.gs_serial, 0)

    let updated = MirrorStatus {
        credit_id: credit_id,
        gs_serial: new_gs_serial,
        state: existing.state,
        bridge_locked: existing.bridge_locked,
        last_updated: now(),
        retry_count: existing.retry_count,
        error_code: if serial_valid { 0 } else { 4040 },
        sdg_score: existing.sdg_score,
    }
    eslite_insert("gs_mirror_mappings", credit_id, updated)
    eslite_insert("gs_mirror_by_serial", new_gs_serial, updated)

    updated
}

stream gs_webhook_events: event<WebhookPayload>
    retention 10y
    consumers [registry, compliance, audit, streamsight]

stream gs_mirror_status_events: event<MirrorStatus>
    retention 10y
    consumers [registry, compliance, audit, streamsight]

stream gs_validation_events: event<GoldStandardValidation>
    retention 10y
    consumers [registry, compliance, audit]

stream gs_sync_conflict_events: event<SyncConflict>
    retention 10y
    consumers [registry, compliance, audit, streamsight]

stream gs_bridge_tx_events: event<BridgeTransaction>
    retention 10y
    consumers [registry, compliance, audit]
